#summary Release notes for the 0.2 version of libkml

= Introduction =

Welcome to the second public release of libkml! 

THIS IS ALPHA SOFTWARE. Expect changes. We recommend caution in use in production code.

This is an initial preview of libkml, and while the general interfaces described are now fairly stable, there is the potential for change! As KML 2.2 is now an [http://www.opengeospatial.org/ Open Geospatial Consortium] (OGC) standard, the language itself is now stable. It is the intention of libkml to adhere strictly to the OGC KML 2.2 standard. 

= What is libkml? =

This is a library to parse, serialize and programmatically access a KML document object model (DOM). The main API is C++, and there are bindings to Python, and Java.

= Who uses libkml? =

We do!  We regularily process the millions of KML files crawled by Google using
this software.  We verify correctness of the KML we publish as Google Earth layers
using libkml.

= Licensing =

The libkml software is distributed under the new BSD license, whose text is found at the top of each file.

= Supported platforms =

This library has been compiled and tested on Windows XP, Mac OS X 10.4 and 10.5, and various flavors of Linux.

= Changes since 0.1 =

Two main things have changed since 0.1: we have upgraded to a memory management
scheme based on "smart pointers", and we have upgraded to automake.

Note that our "smart pointer" scheme is currently only supported by SWIG in Java and Python. Consequently, libkml version 0.2 represents a temporary drop of support for PHP, Perl, and Ruby. It is not our intention to leave these scripting languages behind permanently, what you're witnessing is live development progress. A future release will rectify this issue.

We also provide Microsoft Visual Studio project files.

= Building and installing libkml =

TODO: update this to automake

To build and install libkml from source you first need to install [http://www.scons.org/ SCons version 0.97].

For many people, building libkml from source will be as simple as typing:

{{{
scons
}}}

Use the PREFIX argument as follows to install libkml in a location other than the default:

{{{
scons PREFIX=/your/root install
}}}

You may also use LIBDIR and INCDIR to specify completely separate lib and include directories.

[http://expat.sourceforge.net/ Expat version 2.0.1] is the XML parser used in libkml, and must be installed separately. You tell SCons where to find the Expat library and header files like so:

{{{
scons EXPAT_LIBDIR=/your/root/lib EXPAT_INCDIR=/your/root/include
}}}

Note: on Linux and Mac, we try to make reasonable guesses at whether your system will prefer /usr or /usr/local as a prefix to the default include and lib directories it takes as defaults. If we find expat.h at /usr/include, we assume the /usr prefix for all other third-party system libraries and headers. You can override this with the explicit command line flags seen by running `scons -h`.

If you want to create bindings for the additional supported languages, you need to install the Simplified Wrapper and Interface Generator ([http://www.swig.org/ SWIG]) version 1.3.33. Once SWIG is installed the language bindings are created by default. You may explicitly disable the building of the SWIG extensions by using the RUNSWIG option in SCons as follows:

{{{
scons RUNSWIG=0  # 0 means to not run SWIG to build scripting language bindings
}}}

= Running the unit tests =

IMPORTANT: since libkml does not use RTTI, you _must_ configure cppunit accordingly. On Mac OS X the command is `./configure --disable-typeinfo-name`. On Linux the command is: `./configure --disable-typeinfo-name LIBS="-ldl"`. See the top-level DEPENDENCIES file.

The libkml system includes a large suite of unit tests, written against the [http://cppunit.sourceforge.net CppUnit framework]. Once you have have installed !CppUnit you can build the tests as follows:

{{{
scons CPPUNIT_LIBDIR=/your/root/lib CPPUNIT_INCDIR=/your/root/include
}}}

Note: on Linux and Mac, CPPUNIT_INCDIR defaults to /usr/local/include and CPPUNIT_LIBDIR defaults to /usr/local/lib. This matches !CppUnit's own installation defaults.

To run the tests, invoke SCons as follows:

{{{
scons runtests
}}}

The test output looks as follows:

{{{
...
kmz_test PASSED (Test Binaries: 1 passed, 0 failed)
...
abstractlatlonbox_test PASSED (Test Binaries: 2 passed, 0 failed)
...
...
xsd_test PASSED (Test Binaries: 42 passed, 0 failed)
...
}}}

= Hello libkml =

Here are some small sample programs to show you how to program with libkml.
These are
[http://code.google.com/p/libkml/source/browse/trunk/examples/helloworld/parsekml.cc parsekml.cc],
[http://code.google.com/p/libkml/source/browse/trunk/examples/helloworld/createkml.cc createkml.cc],
and
[http://code.google.com/p/libkml/source/browse/trunk/examples/helloworld/sortplacemarks.cc sortplacemarks.cc]
from the sample suite available [http://code.google.com/p/libkml/source/browse/trunk/examples here].

{{{
// parsekml.cc
// This program parses a KML Placemark from a memory buffer and prints
// the value of the <name> element on standard output.

#include <iostream>
#include <string>
#include "kml/dom.h"  // The KML DOM header.

int main() {
  // Parse KML from a memory buffer.
  std::string errors;
  kmldom::ElementPtr element = kmldom::Parse(
    "<kml>"
      "<Placemark>"
        "<name>hi</name>"
        "<Point>"
          "<coordinates>1,2,3</coordinates>"
        "</Point>"
      "</Placemark>"
    "</kml>",
    &errors);

  // Convert the type of the root element of the parse.
  const kmldom::KmlPtr kml = kmldom::AsKml(element);
  const kmldom::PlacemarkPtr placemark = kmldom::AsPlacemark(kml->feature());

  // Access the value of the <name> element.
  std::cout << "The Placemark name is: " << placemark->name()
    << std::endl;
}
}}}

Another example:

{{{
// createkml.cc
// This program uses the KmlFactory to create a Point Placemark and
// prints the resultant KML on standard output.

#include <iostream>
#include <string>
#include "kml/dom.h"

// libkml types are in the kmldom namespace
using kmldom::CoordinatesPtr;
using kmldom::KmlPtr;
using kmldom::KmlFactory;
using kmldom::PlacemarkPtr;
using kmldom::PointPtr;

int main() {
  // Get the factory singleton to create KML elements.
  KmlFactory* factory = KmlFactory::GetFactory();

  // Create <coordinates>.
  CoordinatesPtr coordinates = factory->CreateCoordinates();
  // Create <coordinates>-122.0816695,37.42052549<coordinates>
  coordinates->add_point2(-122.0816695,37.42052549);

  // Create <Point> and give it <coordinates>.
  PointPtr point = factory->CreatePoint();
  point->set_coordinates(coordinates);  // point takes ownership

  // Create <Placemark> and give it a <name> and the <Point>.
  PlacemarkPtr placemark = factory->CreatePlacemark();
  placemark->set_name("Cool Statue");
  placemark->set_geometry(point);  // placemark takes ownership

  // Create <kml> and give it <Placemark>.
  KmlPtr kml = factory->CreateKml();
  kml->set_feature(placemark);  // kml takes ownership.

  // Serialize to XML
  std::string xml = kmldom::SerializePretty(kml);

  // Print to stdout
  std::cout << xml;
}
}}}

This code fragment shows that is is possible to hold references to Elements
in a given parse tree after the reference to the root of this tree is discarded.

{{{
// sortplacemarks.cc
// This program demonstrates some capabilities of resource management of
// elements in the KML DOM.  An array (std::vector) of PlacemarkPtrs into
// parsed DOM is created.  The DOM root is discarded leaving the only
// references to the underlying Placemarks in the array.  The Placemarks
// are finally discarded when the array goes out of scope.
...
typedef std::vector<PlacemarkPtr> placemark_vector_t;
...
// This function object is used by STL sort() to alphabetize Placemarks
// by <name>.
struct ComparePlacemarks
  : public
      std::binary_function<const PlacemarkPtr&, const PlacemarkPtr&, bool> {
  bool operator()(const PlacemarkPtr& a, const PlacemarkPtr& b) {
    return a->name() < b->name();
  }
};
...
  SavePlacemarks(GetKmlFileRootFeature(argv[1]), &placemark_vector);
  sort(placemark_vector.begin(), placemark_vector.end(), ComparePlacemarks());
  for (size_t i = 0; i < placemark_vector.size(); ++i) {
    cout << i << " " << placemark_vector[i]->id() << " " <<
      placemark_vector[i]->name() << endl;
  }

}}}

= Example programs =

The libkml system comes with a small suite of [http://libkml.googlecode.com/svn/trunk/examples/ example programs] to help you get started. First build and install libkml as described above. Then build the 'helloworld' examples as follows:

TODO: update build instructions to automake

{{{
cd examples/helloworld
scons LIBKML_LIBDIR=/your/root/lib LIBKML_INCDIR=/your/root/include
}}}

If you do not supply an explicit LIBKML_LIBDIR or LIBKML_INCDIR, the libraries and headers in the build directory will be used. 

= Quick reference =

== kmldom ==

The libkml system presently consists of the KML DOM. All classes and functions in the KML DOM are in the kmldom namespace.

== KML 2.2 ==

The libkml DOM implements standard OGC KML 2.2. Google's [http://code.google.com/apis/kml/documentation/ KML documentation] is useful for tutorials, examples, and reference material.

== Creating complex elements ==

Each complex element in KML 2.2 has a C++ type whose name is the same as the element. For example, <Placemark> is kmldom::PlacemarkPtr, and <GroundOverlay> is kmldom::!GroundOverlayPtr.

The !KmlFactory singleton has a method to create each complex element:

{{{
KmlFactory* factory = kmldom::KmlFactory::GetFactory();
kmldom::PlacemarkPtr placemark = factory->CreatePlacemark();
kmldom::FolderPtr folder = factory->CreateFolder();
}}}

== Memory management ==

This release of libkml provides "smart pointer" memory management.
As such the factory returns a "smart pointer" to the created Element
and there is a typedef for each pointer to each complex type in the language.
While this is now a value type it is actually still the same size as a regular
pointer and is also used as a pointer.  (Thus upgrading from 0.1 to 0.2 should
simply require changing any `kmldom::Foo*` to `kmldom::FooPtr`, removing any explicit
calls of delete and recompiling).

The "smart pointer" maintains a reference on your behalf to an Element while the pointer remains in scope.  Passing the Element to set it as a child of another Element gives the parent element a reference.  The reference count decreases when either the parent is deleted or when your smart pointer goes out of scope.

To help enforce the tree nature of XML no Element can be set to more than
one parent.   That is, a given Placemark can be added at most once to
a given Folder and never to a 2nd Folder.

Once an element is set to a given parent, it cannot be detached.

The `clear_xxx()` method both removes the child from the parent and releases its
reference to the underlying storage.

The "smart pointer" scheme is compatible with SWIG and as such no particular
memory management operations are required as is traditional in languages
such as Python and Java.

At present the "smart pointer" is simply a standard Boost intrusive_ptr however
this is not directly considered part of the API.  We strongly encourage
use of the typedefs.

== Setting simple elements ==

Each simple element in KML 2.2 is a field in a complex element. The library provides accessor functions to set, get, clear, and discover the existence of a given simple element.

For example, any Feature (such as Placemark) has a <name> that can be manipulated with these methods:

{{{
const std::string& name() const;
bool has_name() const;
void set_name(const std::string& value);
void clear_name();
}}}

Note that the getter is always `const`.

The `has_xxx()` method returns true if this element was present in the parsed KML or if it was previously set using `set_xxx()`.

The `clear_xxx()` method removes any value set either by the parser or by the `set_xxx()` method. On serialization, no element is emitted for an element that has been cleared.

The getter always returns a value, irrespective of the state returned by `has_xxx()`. If `has_xxx()` is false, then the getter returns the default for this element, as specifed in the KML Reference.

Simple elements are of either `std::string`, `double`, `int`, `boolean` or `enum` type.

Here is how to access the <description> element:

{{{
const std::string& name() const;
bool has_name() const;
void set_name(const std::string& value);
void clear_name();
}}}

Here is how to access the <north> element:

{{{
double north() const;
void set_north(double north);
bool has_north() const;
void set_north(bool north);
}}}

Here is how to access the <drawOrder> element. Note that the name of the element in the accessor
method is folded to all lower case:

{{{
int draworder() const;
void set_draworder(bool draworder);
bool has_draworder() const;
void clear_draworder();
}}}

Here is how to access the <visibility> element:

{{{
bool visibility() const;
void set_visibility(bool visibility);
bool has_visibility() const;
void clear_visibility();
}}}

Here is how to access the <altitudeMode> element:

{{{
int altitudemode() const;
void set_altitudemode(int altitudemode);
bool has_altitudemode() const;
void clear_altitudemode();
}}}

== Enumerated value elements ==

Every enumerated value element has a C++ `enum`. For example, here is the `enum` for <altitudeMode>:

{{{
typedef enum {
  ALTITUDEMODE_CLAMPTOGROUND = 0,
  ALTITUDEMODE_RELATIVETOGROUND,
  ALTITUDEMODE_ABSOLUTE
} AltitudeModeEnum;
}}}

The `enum` type name is the element name with a leading capital and the string 'Enum' appended to it. Thus <colorMode> is of !ColorModeEnum, and <listItemType> is !ListItemTypeEnum.

== More on complex elements ==

There are 3 kinds of complex child accessors: 1) single value of a specific type, 2) single value of a group type, and 3) an array value of either a specific or group type. Here are examples of each.

The <LatLonBox> child of <GroundOverlay> is an example of a complex child of a specific type:

{{{
const LatLonBoxPtr& latlonbox() const;
void set_latlonbox(const LatLonBoxPtr& latlonbox);
bool has_latlonbox() const;
void clear_latlonbox();
}}}

The !AbstractView child of Feature is an example of a complex child of a group type. Both <LookAt> and <Camera> can be used with these accessors.

{{{
const AbstractViewPtr& abstractview() const;
void set_abstractview(const AbstractViewPtr& abstractview);
bool has_abstractview() const;
void clear_abstractview();
}}}

The Feature child of <Folder> is an example of an array value of a group type:

{{{
void add_feature(const FeaturePtr& feature);
size_t feature_array_size() const;
const kmldom::FeaturePtr& feature_array_at(unsigned int index) const;
}}}

(Note that in KML 2.2 the following elements are all of Feature type: Placemark, !NetworkLink, !GroundOverlay, !ScreenOverlay, !PhotoOverlay, Folder, and Document)

== Type inspection and conversion ==

All complex elements are derived from `kmldom::Element`. There is a type conversion and an inspection function for each complex type. The libkml system is not built with run-time type information (RTTI), hence `dynamic_cast` is not used. If the element is of the desired type, then a pointer of that type is returned, else NULL.

For example, the following code accesses the Geometry of a Placemark to discover if it is a Point:

{{{
const kmldom::PlacemarkPtr placemark;
...
if (placemark->has_geometry()) {
  if (const kmldom::PointPtr point = kmldom::AsPoint(placemark->geometry()) {
    // Yes, it is a Point... see if it has coordinates:
    if (point->has_coordinates()) {
      ...
    }
  }
}
}}}

Every element has a type id that can be accessed with the Type() method:

{{{
const FeaturePtr feature = kml->feature();
if (feature->Type() == Type_Placemark) {
  // Yes, this is a Placemark
}
}}}

Every element has an IsA() method to inquire the specific or group type of an element:

{{{
GroundOverlayPtr overlay = KmlFactory()->CreateGroundOverlay();
assert(overlay->IsA(kmldom::Type_Object));
assert(overlay->IsA(kmldom::Type_Feature));
assert(overlay->IsA(kmldom::Type_Overlay));
assert(overlay->IsA(kmldom::Type_GroundOverlay));
}}}

= Future development =

With this 0.2 release we hope to soon freeze the API to the kmldom namespace.
Future development will be on the KML "Engine" built on the KML DOM.

  * full kmz read and write
  * object id management
  * xml namespace support
  * style resolution
  * balloon template expansion
  * networklink fetching
  * feature and geometry bounding box and lookat/camera computation
  * region visibility computation
  * NetworkLinkControl/Update processing
  * regionator framework

= Found a bug? =

You can file a bug using this project's [http://code.google.com/p/libkml/issues/list issue tracker]. Please follow basic [http://www.google.com/search?q=bug+reporting+guidelines bug reporting procedure] and provide as much information as possible.